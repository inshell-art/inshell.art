#!/usr/bin/env -S node --enable-source-maps
import { readFile, writeFile, mkdir } from "node:fs/promises";
import { dirname, resolve } from "node:path";
import process from "node:process";

/** Narrow check: Array.isArray but returns a typed guard */
const isArray = (x: unknown): x is readonly unknown[] => Array.isArray(x);

function extractAbi(parsed: unknown): readonly unknown[] | null {
  if (isArray(parsed)) return parsed; // plain ABI array
  if (parsed && typeof parsed === "object" && isArray((parsed as any).abi)) {
    return (parsed as any).abi; // { abi: [...] }
  }
  return null;
}

async function main(): Promise<void> {
  const [inPathArg, outPathArg, exportNameArg] = process.argv.slice(2);

  if (!inPathArg || !outPathArg) {
    console.error(
      "Usage: tsx scripts/abi-json-to-ts.ts <in.json> <out.ts> [ExportName]"
    );
    process.exit(1);
  }

  const inPath = resolve(inPathArg);
  const outPath = resolve(outPathArg);

  // Default export name "ABI"; validate if a custom one is provided
  const exportName =
    exportNameArg && /^[A-Za-z_]\w*$/.test(exportNameArg)
      ? exportNameArg
      : "ABI";

  // Read + parse input JSON
  const raw = await readFile(inPath, "utf8");
  let parsed: unknown;
  try {
    parsed = JSON.parse(raw);
  } catch (e) {
    console.error(`Failed to parse JSON: ${inPath}`);
    throw e;
  }

  // Accept either a plain array or { abi: [...] }
  const abi = extractAbi(parsed);
  if (!abi) {
    console.error(
      "Input doesn't look like a Starknet ABI (array or {abi: [...]})"
    );
    process.exit(1);
  }

  const header = `/* Autogenerated from ${inPath}. Do not edit manually. */\n`;
  const json = JSON.stringify(abi, null, 2);
  const body = `export const ${exportName} = ${json} as const;
export default ${exportName};
`;

  await mkdir(dirname(outPath), { recursive: true });
  await writeFile(outPath, header + body, "utf8");
  console.log(`Wrote ${outPath}`);
}

main().catch((e) => {
  console.error(e instanceof Error ? e.stack ?? e.message : String(e));
  process.exit(1);
});
